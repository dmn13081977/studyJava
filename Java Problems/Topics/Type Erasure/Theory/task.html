<h2>Type Erasure</h2>
<div class="step-text">
<p>Generics were introduced to implement generic programming and control type-safety at compile-time. The feature has been available since Java 5. To support backward compatibility with previous Java versions, information about generic types is erased by the compiler. We will cover exactly which types are erased in future topics.</p>
<p>This means that at runtime all these objects will have the same type:</p>
<pre><code class="language-java">// Generic types
List&lt;Integer&gt; integers = new List&lt;&gt;();
List&lt;String&gt; strings = new List&lt;&gt;();

// Raw type
List objects = new List();</code></pre>
<p>The transformation process is called type erasure. Let's take a closer look at what it actually does.</p>
<h5 id="generics-replacement">Generics replacement</h5>
<p>First of all, type erasure replaces parameters of generic types with their bounds. Unbounded types are replaced by <code class="language-java">Object</code>. This means that information about types is erased when a program is translated into byte code. As a result, byte code contains only ordinary non-generic classes and interfaces.</p>
<p>Let's consider the generic class <code class="language-java">Data</code>:</p>
<pre><code class="language-java">class Data&lt;T&gt; {
    private T data;

    public T get() {
        return data;
    }

    public void set(T data) {
        this.data = data;
    }
}
</code></pre>
<p>The Java compiler will replace the parameter <code class="language-java">T</code> with <code class="language-java">Object</code>, because <code class="language-java">T</code> is unbounded. Below is code that is effectively the same as <code class="language-java">Data&lt;T&gt;</code> after compilation:</p>
<pre><code class="language-java">class Data {
    private Object data;

    public Object get() {
        return data;
    }

    public void set(Object data) {
        this.data = data;
    }
}</code></pre>
<p>Now suppose <code class="language-java">Data</code> is parameterized by <code class="language-java">&lt;T extends Number&gt;</code>. In this case, the transformed code will look similar to the last code snippet with one difference: <code class="language-java">Object</code> will be replaced by <code class="language-java">Number</code>.</p>
<p>If a value is assigned, a generic replacement can affect the accuracy of the program. If it is necessary to preserve type safety, the compiler inserts type casting. Let's look at the code:</p>
<pre><code class="language-java">Data&lt;String&gt; data = new Data("stored value");
String stored = data.get();</code></pre>
<p>After type erasure is performed the code above is equivalent to:</p>
<pre><code class="language-java">Data data = new Data("stored value");
String stored = (String) data.get();</code></pre>
<h5 id="bridge-methods">Bridge methods</h5>
<p>In order to preserve polymorphism through type casting, sometimes the compiler has to generate synthetic methods. Let's consider an extension of the <code class="language-java">Data</code> class:</p>
<pre><code class="language-java">public class NumberData extends Data&lt;Number&gt; {
    public void set(Number number) {
        System.out.println("NumberData set");
        super.set(number);
    }
}</code></pre>
<p>After type erasure, the <code class="language-java">NumberData</code> method remains <code class="language-java">set(Number number)</code>, while the original <code class="language-java">Data</code> method is <code class="language-java">set(Object obj)</code>. Because <code class="language-java">NumberData extends Data</code>, it is possible to invoke <code class="language-java">set(Object obj)</code> from an instance of <code class="language-java">NumberData</code> and set objects of arbitrary type. But we only want to set objects of the <code class="language-java">Number</code> type. To solve this problem and preserve the polymorphism of generic types after type erasure, the Java compiler generates a so-called <em>bridge method</em> in the <code class="language-java">NumberData</code> class. It overrides parameterized parent methods and provides type casting to specific parameters:</p>
<pre><code class="language-java">public class NumberData extends Data {
    // Bridge method generated by the compiler
    public void set(Object object) {
        set((Number) object);
    }

    public void set(Number number) {
        super.set(number);
    }

    ...
}</code></pre>
<p>A bridge method is a synthetic method created by the compiler as part of the type erasure process. It exists in byte code only and not available for direct usage from Java code. Normally you don't directly encounter bridge methods, although sometimes they might appear in a stack trace.</p>
<h5 id="conclusion">Conclusion</h5>
<p>Type erasure is an operation that the Java Virtual Machine (JVM) runs during the compilation of source code to byte code. It replaces generic type parameters with their upper bounds. It also inserts type casting and generates bridge methods to preserve type safety. Type erasure plays an important role in Java's implementation of generics.</p>
</div>
